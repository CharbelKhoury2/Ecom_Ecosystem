/**
 * Export utilities for generating reports in various formats
 */

import jsPDF from 'jspdf';
import 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { format } from 'date-fns';

export interface ExportData {
  title: string;
  data: Record<string, unknown>[];
  columns: { key: string; label: string; width?: number }[];
  summary?: SummaryItem[];
  metadata?: {
    generatedBy?: string;
    dateRange?: string;
    filters?: string[];
  };
}

export interface SummaryItem {
  label: string;
  value: string | number;
  type?: 'currency' | 'number' | 'percentage';
}

interface ColumnDefinition {
  key: string;
  label: string;
  type: 'text' | 'number' | 'currency' | 'date' | 'percentage';
  filterable?: boolean;
  sortable?: boolean;
  format?: string;
}

export interface ChartData {
  type: 'bar' | 'line' | 'pie' | 'area';
  title: string;
  data: Record<string, unknown>[];
  xKey: string;
  yKey: string;
  color?: string;
}

/**
 * Export data to CSV format
 */
export const exportToCSV = (exportData: ExportData): void => {
  const { title, data, columns } = exportData;
  
  // Create CSV headers
  const headers = columns.map(col => col.label).join(',');
  
  // Create CSV rows
  const rows = data.map(row => 
    columns.map(col => {
      const value = row[col.key];
      // Escape commas and quotes in values
      if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value || '';
    }).join(',')
  );
  
  // Combine headers and rows
  const csvContent = [headers, ...rows].join('\n');
  
  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', `${title.replace(/\s+/g, '_')}_${format(new Date(), 'yyyy-MM-dd')}.csv`);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/**
 * Export data to Excel format
 */
export const exportToExcel = (exportData: ExportData | ExportData[]): void => {
  const workbook = XLSX.utils.book_new();
  const dataArray = Array.isArray(exportData) ? exportData : [exportData];
  
  dataArray.forEach((data) => {
    const { title, data: tableData, columns, summary, metadata } = data;
    
    // Create worksheet data
    const wsData: (string | number | boolean | null)[][] = [];
    
    // Add title
    wsData.push([title]);
    wsData.push([]);
    
    // Add metadata if available
    if (metadata) {
      if (metadata.generatedBy) wsData.push(['Generated by:', metadata.generatedBy]);
      if (metadata.dateRange) wsData.push(['Date Range:', metadata.dateRange]);
      if (metadata.filters?.length) {
        wsData.push(['Filters:', metadata.filters.join(', ')]);
      }
      wsData.push([]);
    }
    
    // Add headers
    wsData.push(columns.map(col => col.label));
    
    // Add data rows
    tableData.forEach(row => {
      wsData.push(columns.map(col => row[col.key] || ''));
    });
    
    // Add summary if available
    if (summary?.length) {
      wsData.push([]);
      wsData.push(['Summary']);
      summary.forEach(item => {
        wsData.push([item.label, item.value]);
      });
    }
    
    // Create worksheet
    const ws = XLSX.utils.aoa_to_sheet(wsData);
    
    // Set column widths
    const colWidths = columns.map(col => ({ wch: col.width || 15 }));
    ws['!cols'] = colWidths;
    
    // Add worksheet to workbook
    const sheetName = dataArray.length > 1 ? `${title.substring(0, 25)}_${Math.random().toString(36).substr(2, 5)}` : title.substring(0, 31);
    XLSX.utils.book_append_sheet(workbook, ws, sheetName);
  });
  
  // Generate filename
  const filename = dataArray.length > 1 
    ? `Multi_Report_${format(new Date(), 'yyyy-MM-dd')}.xlsx`
    : `${dataArray[0].title.replace(/\s+/g, '_')}_${format(new Date(), 'yyyy-MM-dd')}.xlsx`;
  
  // Save file
  XLSX.writeFile(workbook, filename);
};

/**
 * Export data to PDF format
 */
export const exportToPDF = (exportData: ExportData, charts?: ChartData[]): void => {
  const { title, data, columns, summary, metadata } = exportData;
  
  // Create new PDF document
  const doc = new jsPDF();
  let yPosition = 20;
  
  // Add title
  doc.setFontSize(18);
  doc.setFont('helvetica', 'bold');
  doc.text(title, 20, yPosition);
  yPosition += 15;
  
  // Add metadata
  if (metadata) {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    
    if (metadata.generatedBy) {
      doc.text(`Generated by: ${metadata.generatedBy}`, 20, yPosition);
      yPosition += 7;
    }
    
    if (metadata.dateRange) {
      doc.text(`Date Range: ${metadata.dateRange}`, 20, yPosition);
      yPosition += 7;
    }
    
    if (metadata.filters?.length) {
      doc.text(`Filters: ${metadata.filters.join(', ')}`, 20, yPosition);
      yPosition += 7;
    }
    
    yPosition += 5;
  }
  
  // Add table
  const tableColumns = columns.map(col => col.label);
  const tableRows = data.map(row => columns.map(col => row[col.key] || ''));
  
  // Use autoTable plugin for jsPDF
  const docWithAutoTable = doc as jsPDF & {
    autoTable: (options: {
      head: string[][];
      body: (string | number)[][];
      startY: number;
      styles: { fontSize: number };
      headStyles: { fillColor: number[] };
      margin: { top: number; right: number; bottom: number; left: number };
    }) => void;
    lastAutoTable: { finalY: number };
  };
  
  docWithAutoTable.autoTable({
    head: [tableColumns],
    body: tableRows.map(row => row.map(cell => String(cell))),
    startY: yPosition,
    styles: { fontSize: 8 },
    headStyles: { fillColor: [66, 139, 202] },
    margin: { top: 20, right: 20, bottom: 20, left: 20 },
  });
  
  // Get final Y position after table
  yPosition = docWithAutoTable.lastAutoTable.finalY + 10;
  
  // Add summary if available
  if (summary?.length) {
    // Check if we need a new page
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 20;
    }
    
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Summary', 20, yPosition);
    yPosition += 10;
    
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    
    summary.forEach(item => {
      doc.text(`${item.label}: ${item.value}`, 20, yPosition);
      yPosition += 7;
    });
  }
  
  // Add charts if provided
  if (charts?.length) {
    charts.forEach((chart) => {
      // Add new page for charts
      doc.addPage();
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text(chart.title, 20, 20);
      
      // Note: For actual chart rendering, you would need to convert
      // the chart to an image first using html2canvas or similar
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text('Chart data visualization would be rendered here', 20, 40);
    });
  }
  
  // Save PDF
  const filename = `${title.replace(/\s+/g, '_')}_${format(new Date(), 'yyyy-MM-dd')}.pdf`;
  doc.save(filename);
};

/**
 * Generate summary statistics from data
 */
export const generateSummary = (data: Record<string, unknown>[], columns: ColumnDefinition[]): SummaryItem[] => {
  const summary: SummaryItem[] = [];
  
  // Total records
  summary.push({ label: 'Total Records', value: data.length });
  
  // Calculate summaries for numeric columns
  columns.forEach(col => {
    if (col.type === 'number' || col.type === 'currency') {
      const values = data.map(row => parseFloat(row[col.key] as string) || 0).filter((val): val is number => typeof val === 'number');
      const total = values.reduce((sum, val) => sum + val, 0);
      const average = values.length > 0 ? total / values.length : 0;
      
      if (col.type === 'currency') {
        summary.push({ label: `Total ${col.label}`, value: `$${total.toLocaleString('en-US', { minimumFractionDigits: 2 })}` });
        summary.push({ label: `Average ${col.label}`, value: `$${average.toLocaleString('en-US', { minimumFractionDigits: 2 })}` });
      } else {
        summary.push({ label: `Total ${col.label}`, value: total.toLocaleString() });
        summary.push({ label: `Average ${col.label}`, value: average.toFixed(2) });
      }
    }
  });
  
  return summary;
};

/**
 * Format data for export based on column types
 */
export const formatDataForExport = (data: Record<string, unknown>[], columns: ColumnDefinition[]): Record<string, unknown>[] => {
  return data.map((row: Record<string, unknown>) => {
    const formattedRow: Record<string, unknown> = {};
    
    columns.forEach(col => {
      let value = row[col.key];
      
      switch (col.type) {
        case 'currency':
          value = typeof value === 'number' ? `$${value.toLocaleString('en-US', { minimumFractionDigits: 2 })}` : value;
          break;
        case 'percentage':
          value = typeof value === 'number' ? `${(value * 100).toFixed(2)}%` : value;
          break;
        case 'date':
          value = value ? format(new Date(value as string), 'yyyy-MM-dd') : value;
          break;
        case 'number':
          value = typeof value === 'number' ? value.toLocaleString() : value;
          break;
        default:
          // Keep original value
          break;
      }
      
      formattedRow[col.key] = value;
    });
    
    return formattedRow;
  });
};

/**
 * Validate export data structure
 */
export const validateExportData = (data: ExportData): boolean => {
  return !!(data.title && data.data && Array.isArray(data.data) && data.columns && Array.isArray(data.columns));
};

/**
 * Validate export data with detailed errors
 */
export const validateExportDataDetailed = (exportData: ExportData): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];
  
  if (!exportData.title || exportData.title.trim() === '') {
    errors.push('Title is required');
  }
  
  if (!exportData.data || !Array.isArray(exportData.data)) {
    errors.push('Data must be an array');
  }
  
  if (!exportData.columns || !Array.isArray(exportData.columns) || exportData.columns.length === 0) {
    errors.push('Columns are required');
  }
  
  // Validate column structure
  exportData.columns?.forEach((col) => {
    if (!col.key || !col.label) {
      errors.push('Column must have both key and label');
    }
  });
  
  return {
    isValid: errors.length === 0,
    errors
  };
};